# -*- coding: utf-8 -*-
"""clustering_masterdata.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fa_OWsz4tjs0UBWxFwfvPJ4vyVg2kCko
"""

import numpy as np
import pandas as pd

from google.colab import drive
drive.mount('/content/drive')

df=pd.read_csv('/content/drive/MyDrive/master data set.csv')



df

df.columns

col=['ACS_AVG_HH_SIZE',
'ACS_GINI_INDEX',
'ACS_MEDIAN_AGE',
'ACS_MEDIAN_AGE_FEMALE',
'ACS_MEDIAN_AGE_MALE',
'ACS_MEDIAN_HH_INC',

'ACS_MEDIAN_HH_INC_HISP',


'ACS_MEDIAN_HH_INC_WHITE',
'ACS_MEDIAN_INC_F',
'ACS_MEDIAN_INC_M',
'ACS_MEDIAN_NONVET_INC',
'ACS_MEDIAN_VET_INC',
'ACS_PCT_AGE_0_17',
'ACS_PCT_AGE_0_4',
'ACS_PCT_AGE_10_14',
'ACS_PCT_AGE_15_17',
'ACS_PCT_AGE_18_29',
'ACS_PCT_AGE_18_44',
'ACS_PCT_AGE_30_44',
'ACS_PCT_AGE_45_64',
'ACS_PCT_AGE_50_64',
'ACS_PCT_AGE_5_9',
'ACS_PCT_AGE_ABOVE65',
'ACS_PCT_AGE_ABOVE80',
'ACS_PCT_AIAN',
'ACS_PCT_AIAN_COMB',

'ACS_PCT_AIAN_NONHISP',
'ACS_PCT_API_LANG',
'ACS_PCT_ASIAN',
'ACS_PCT_ASIAN_COMB',
'ACS_PCT_ASIAN_FEMALE',
'ACS_PCT_ASIAN_MALE',
'ACS_PCT_ASIAN_NONHISP',
'ACS_PCT_BACHELOR_DGR',
'ACS_PCT_BLACK',
'ACS_PCT_BLACK_COMB',
'ACS_PCT_BLACK_FEMALE',
'ACS_PCT_BLACK_MALE',
'ACS_PCT_BLACK_NONHISP',
'ACS_PCT_CHILDREN_GRANDPARENT',
'ACS_PCT_CHILD_1FAM',
'ACS_PCT_CHILD_DISAB',
'ACS_PCT_COLLEGE_ASSOCIATE_DGR',
'ACS_PCT_COMMT_15MIN',
'ACS_PCT_COMMT_29MIN',
'ACS_PCT_COMMT_59MIN',
'ACS_PCT_COMMT_60MINUP',
'ACS_PCT_DISABLE',
'ACS_PCT_ENGL_NOT_ALL',
'ACS_PCT_ENGL_NOT_WELL',
'ACS_PCT_FOREIGN_BORN',
'ACS_PCT_GRADUATE_DGR',
'ACS_PCT_HEALTH_INC_138_199',
'ACS_PCT_HEALTH_INC_200_399',
'ACS_PCT_HEALTH_INC_ABOVE400',
'ACS_PCT_HEALTH_INC_BELOW137',
'ACS_PCT_HH_1PERS',
'ACS_PCT_HH_ABOVE65',
'ACS_PCT_HH_ALONE_ABOVE65',
'ACS_PCT_HH_BROADBAND',
'ACS_PCT_HH_BROADBAND_ANY',
'ACS_PCT_HH_BROADBAND_ONLY',
'ACS_PCT_HH_CELLULAR',
'ACS_PCT_HH_CELLULAR_ONLY',
'ACS_PCT_HH_DIAL_INTERNET_ONLY',
'ACS_PCT_HH_FOOD_STMP',
'ACS_PCT_HH_FOOD_STMP_BLW_POV',
'ACS_PCT_HH_INC_10000',
'ACS_PCT_HH_INC_100000',
'ACS_PCT_HH_INC_14999',
'ACS_PCT_HH_INC_24999',
'ACS_PCT_HH_INC_49999',
'ACS_PCT_HH_INC_99999',
'ACS_PCT_HH_INTERNET',
'ACS_PCT_HH_INTERNET_NO_SUBS',
'ACS_PCT_HH_LIMIT_ENGLISH',
'ACS_PCT_HH_NO_COMP_DEV',
'ACS_PCT_HH_NO_FD_STMP_BLW_POV',
'ACS_PCT_HH_NO_INTERNET',
'ACS_PCT_HH_OTHER_COMP',
'ACS_PCT_HH_OTHER_COMP_ONLY',
'ACS_PCT_HH_PC',
'ACS_PCT_HH_PC_ONLY',
'ACS_PCT_HH_PUB_ASSIST',
'ACS_PCT_HH_SAT_INTERNET',
'ACS_PCT_HH_SMARTPHONE',
'ACS_PCT_HH_SMARTPHONE_ONLY',
'ACS_PCT_HH_TABLET',
'ACS_PCT_HH_TABLET_ONLY',
'ACS_PCT_HS_GRADUATE',
'ACS_PCT_HU_MOBILE_HOME',
'ACS_PCT_HU_NO_VEH',
'ACS_PCT_LT_HS',
'ACS_PCT_MEDICAID_ANY',
'ACS_PCT_MEDICAID_ANY_BELOW64',
'ACS_PCT_MEDICARE_ONLY',
'ACS_PCT_MULT_RACE',
'ACS_PCT_NONVET_DISABLE_18_64',
'ACS_PCT_OTHER_INS',
'ACS_PCT_OWNER_HU_COST_30PCT',
'ACS_PCT_OWNER_HU_COST_50PCT',
'ACS_PCT_POSTHS_ED',
'ACS_PCT_PRIVATE_ANY',
'ACS_PCT_PRIVATE_ANY_BELOW64',
'ACS_PCT_PRIVATE_EMPL',
'ACS_PCT_PRIVATE_EMPL_BELOW64',
'ACS_PCT_PRIVATE_MDCR',
'ACS_PCT_PRIVATE_MDCR_35_64',
'ACS_PCT_PRIVATE_OTHER',
'ACS_PCT_PRIVATE_OTHER_BELOW64',
'ACS_PCT_PRIVATE_SELF',
'ACS_PCT_PRIVATE_SELF_BELOW64',
'ACS_PCT_PUBLIC_OTHER',
'ACS_PCT_PUBLIC_ONLY',
'ACS_PCT_PUBLIC_OTHER_BELOW64',
'ACS_PCT_PUBL_TRANSIT',
'ACS_PCT_PUB_COMMT_15MIN',
'ACS_PCT_PUB_COMMT_29MIN',
'ACS_PCT_PUB_COMMT_59MIN',
'ACS_PCT_PUB_COMMT_60MINUP',
'ACS_PCT_PVT_EMPL_DRCT',
'ACS_PCT_PVT_EMPL_DRCT_BELOW64',
'ACS_PCT_RENTER_HU_ABOVE65',
'ACS_PCT_RENTER_HU_COST_30PCT',
'ACS_PCT_RENTER_HU_COST_50PCT',
'ACS_PCT_SELF_MDCR_ABOVE35',
'ACS_PCT_TAXICAB_2WORK',
'ACS_PCT_TRICARE_VA',
'ACS_PCT_TRICARE_VA_BELOW64',
'ACS_PCT_UNEMPLOY',
'ACS_PCT_UNINSURED',
'ACS_PCT_UNINSURED_BELOW64',
'ACS_PCT_VET',
'ACS_PCT_VET_BACHELOR',
'ACS_PCT_VET_COLLEGE',
'ACS_PCT_VET_DISABLE_18_64',
'ACS_PCT_VET_HS',
'ACS_PCT_VET_LABOR_FORCE_18_64',
'ACS_PCT_VET_POV_18_64',
'ACS_PCT_VET_UNEMPL_18_64',
'ACS_PCT_WALK_2WORK',
'ACS_PCT_WHITE',
'ACS_PCT_WORK_NO_CAR',
'ACS_PER_CAPITA_INC',
'ACS_TOT_CIVIL_VET_POP',
'ACS_TOT_CIVIL_VET_POP_ABOVE25',
'ACS_TOT_GRANDCHILDREN_GP',
'ACS_TOT_HH',
'ACS_TOT_HU',
'ACS_TOT_POP_16_19',
'ACS_TOT_POP_ABOVE15',
'ACS_TOT_POP_ABOVE16',
'ACS_TOT_POP_ABOVE25',
'ACS_TOT_POP_ABOVE5',
'ACS_TOT_POP_US_ABOVE1',
'ACS_TOT_POP_WT',
'ACS_TOT_WORKER_NWFH'
]



df[col].isnull().sum()

import seaborn as sns
plt.figure(figsize=(20, 16));
sns.heatmap(df.isnull(), cmap='viridis')
plt.show()

import pandas as pd

# Assuming df is your DataFrame

# Count the number of non-null values in each row
non_null_counts = df.notnull().sum(axis=1)

# Filter out rows with more than 156 non-null values
filtered_df = df[non_null_counts >= (len(df.columns) - 156)]

print(filtered_df)

df=filtered_df

#replacing nan values
df[col] = df[col].fillna(df.median())

from sklearn.preprocessing import MinMaxScaler



# Initialize MinMaxScaler
scaler = MinMaxScaler()

# Apply MinMaxScaler to the numerical columns
df[col] = scaler.fit_transform(df[col])

# Now df contains the scaled values

df

from sklearn.cluster import KMeans
import matplotlib.pyplot as plt

# Assuming 'X' is your data

# Calculate WCSS for different values of k
wcss = []
for i in range(1, 11):
    kmeans = KMeans(n_clusters=i, init='k-means++', random_state=42)
    kmeans.fit(df[col])
    wcss.append(kmeans.inertia_)

# Plot the Elbow Method graph
plt.plot(range(1, 11), wcss)
plt.title('Elbow Method')
plt.xlabel('Number of clusters')
plt.ylabel('WCSS')
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score

# Assuming X is your data
# X should be a numpy array or pandas DataFrame
# You can choose a range of k values to try
k_values = range(2, 6)
silhouette_scores = []

for k in k_values:
    kmeans = KMeans(n_clusters=k, random_state=42)
    cluster_labels = kmeans.fit_predict(df[col])
    silhouette_avg = silhouette_score(df[col], cluster_labels)
    silhouette_scores.append(silhouette_avg)

# Plot the silhouette scores
plt.plot(k_values, silhouette_scores, marker='o')
plt.xlabel('Number of clusters (k)')
plt.ylabel('Silhouette score')
plt.title('Silhouette Score for KMeans Clustering')
plt.grid(True)
plt.show()

from sklearn.cluster import KMeans
from sklearn.cluster import AgglomerativeClustering
import matplotlib.pyplot as plt
# Number of clusters
n_clusters = 3

# K-means clustering
kmeans = KMeans(n_clusters=n_clusters, random_state=42)
kmeans_cluster_labels = kmeans.fit_predict(df[col])

from sklearn.cluster import KMeans

# Assuming kmeans is the fitted KMeans object
# Assuming df is your DataFrame

# Get the cluster labels
cluster_labels = kmeans.labels_

# Add the cluster labels as a new column to the DataFrame
df['Cluster_Labels'] = cluster_labels

# Now df contains a new column 'Cluster_Labels' with the cluster labels

df

col_drop=['ACS_MEDIAN_HH_INC_AIAN',
 'ACS_MEDIAN_HH_INC_ASIAN',
 'ACS_MEDIAN_HH_INC_BLACK',
 'ACS_MEDIAN_HH_INC_MULTI',
 'ACS_MEDIAN_HH_INC_NHPI',
 'ACS_MEDIAN_HH_INC_OTHER']



import plotly.express as px


# Assuming 'df' is your DataFrame with cluster labels assigned
# You should have a column named 'cluster' containing the cluster labels

# Plot parallel coordinates
fig = px.parallel_coordinates(df, color="Cluster_Labels")
fig.show()

# Create separate DataFrames for each cluster
df0 = df[df['Cluster_Labels'] == 0]
df1 = df[df['Cluster_Labels'] == 1]
df2 = df[df['Cluster_Labels'] == 2]


# Now you have separate DataFrames for each cluster

df0

df1

df2

df0.to_csv('/content/drive/My Drive/df0.csv', index=False)
df1.to_csv('/content/drive/My Drive/df1.csv', index=False)
df2.to_csv('/content/drive/My Drive/df2.csv', index=False)

